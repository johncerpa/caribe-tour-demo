// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'plans_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

mixin _$PlansEvent {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result started(),
    @required Result loadingUserPlans(),
    @required Result streamPlanss(),
  });

  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result started(),
    Result loadingUserPlans(),
    Result streamPlanss(),
    @required Result orElse(),
  });

  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result started(_Started value),
    @required Result loadingUserPlans(_LoadingUserPlans value),
    @required Result streamPlanss(_StreanPlans value),
  });

  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result started(_Started value),
    Result loadingUserPlans(_LoadingUserPlans value),
    Result streamPlanss(_StreanPlans value),
    @required Result orElse(),
  });
}

class _$PlansEventTearOff {
  const _$PlansEventTearOff();

  _Started started() {
    return const _Started();
  }

  _LoadingUserPlans loadingUserPlans() {
    return const _LoadingUserPlans();
  }

  _StreanPlans streamPlanss() {
    return const _StreanPlans();
  }
}

const $PlansEvent = _$PlansEventTearOff();

class _$_Started implements _Started {
  const _$_Started();

  @override
  String toString() {
    return 'PlansEvent.started()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Started);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result started(),
    @required Result loadingUserPlans(),
    @required Result streamPlanss(),
  }) {
    assert(started != null);
    assert(loadingUserPlans != null);
    assert(streamPlanss != null);
    return started();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result started(),
    Result loadingUserPlans(),
    Result streamPlanss(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result started(_Started value),
    @required Result loadingUserPlans(_LoadingUserPlans value),
    @required Result streamPlanss(_StreanPlans value),
  }) {
    assert(started != null);
    assert(loadingUserPlans != null);
    assert(streamPlanss != null);
    return started(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result started(_Started value),
    Result loadingUserPlans(_LoadingUserPlans value),
    Result streamPlanss(_StreanPlans value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements PlansEvent {
  const factory _Started() = _$_Started;
}

class _$_LoadingUserPlans implements _LoadingUserPlans {
  const _$_LoadingUserPlans();

  @override
  String toString() {
    return 'PlansEvent.loadingUserPlans()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LoadingUserPlans);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result started(),
    @required Result loadingUserPlans(),
    @required Result streamPlanss(),
  }) {
    assert(started != null);
    assert(loadingUserPlans != null);
    assert(streamPlanss != null);
    return loadingUserPlans();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result started(),
    Result loadingUserPlans(),
    Result streamPlanss(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadingUserPlans != null) {
      return loadingUserPlans();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result started(_Started value),
    @required Result loadingUserPlans(_LoadingUserPlans value),
    @required Result streamPlanss(_StreanPlans value),
  }) {
    assert(started != null);
    assert(loadingUserPlans != null);
    assert(streamPlanss != null);
    return loadingUserPlans(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result started(_Started value),
    Result loadingUserPlans(_LoadingUserPlans value),
    Result streamPlanss(_StreanPlans value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadingUserPlans != null) {
      return loadingUserPlans(this);
    }
    return orElse();
  }
}

abstract class _LoadingUserPlans implements PlansEvent {
  const factory _LoadingUserPlans() = _$_LoadingUserPlans;
}

class _$_StreanPlans implements _StreanPlans {
  const _$_StreanPlans();

  @override
  String toString() {
    return 'PlansEvent.streamPlanss()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _StreanPlans);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result started(),
    @required Result loadingUserPlans(),
    @required Result streamPlanss(),
  }) {
    assert(started != null);
    assert(loadingUserPlans != null);
    assert(streamPlanss != null);
    return streamPlanss();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result started(),
    Result loadingUserPlans(),
    Result streamPlanss(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (streamPlanss != null) {
      return streamPlanss();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result started(_Started value),
    @required Result loadingUserPlans(_LoadingUserPlans value),
    @required Result streamPlanss(_StreanPlans value),
  }) {
    assert(started != null);
    assert(loadingUserPlans != null);
    assert(streamPlanss != null);
    return streamPlanss(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result started(_Started value),
    Result loadingUserPlans(_LoadingUserPlans value),
    Result streamPlanss(_StreanPlans value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (streamPlanss != null) {
      return streamPlanss(this);
    }
    return orElse();
  }
}

abstract class _StreanPlans implements PlansEvent {
  const factory _StreanPlans() = _$_StreanPlans;
}

mixin _$PlansState {
  Option<List<Plan>> get initialplans;
  Stream<List<Plan>> get plansStream;

  PlansState copyWith(
      {Option<List<Plan>> initialplans, Stream<List<Plan>> plansStream});
}

class _$PlansStateTearOff {
  const _$PlansStateTearOff();

  _PlansState call(
      {@required Option<List<Plan>> initialplans,
      Stream<List<Plan>> plansStream}) {
    return _PlansState(
      initialplans: initialplans,
      plansStream: plansStream,
    );
  }
}

const $PlansState = _$PlansStateTearOff();

class _$_PlansState implements _PlansState {
  const _$_PlansState({@required this.initialplans, this.plansStream})
      : assert(initialplans != null);

  @override
  final Option<List<Plan>> initialplans;
  @override
  final Stream<List<Plan>> plansStream;

  @override
  String toString() {
    return 'PlansState(initialplans: $initialplans, plansStream: $plansStream)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlansState &&
            (identical(other.initialplans, initialplans) ||
                const DeepCollectionEquality()
                    .equals(other.initialplans, initialplans)) &&
            (identical(other.plansStream, plansStream) ||
                const DeepCollectionEquality()
                    .equals(other.plansStream, plansStream)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(initialplans) ^
      const DeepCollectionEquality().hash(plansStream);

  @override
  _$_PlansState copyWith({
    Object initialplans = freezed,
    Object plansStream = freezed,
  }) {
    return _$_PlansState(
      initialplans: initialplans == freezed
          ? this.initialplans
          : initialplans as Option<List<Plan>>,
      plansStream: plansStream == freezed
          ? this.plansStream
          : plansStream as Stream<List<Plan>>,
    );
  }
}

abstract class _PlansState implements PlansState {
  const factory _PlansState(
      {@required Option<List<Plan>> initialplans,
      Stream<List<Plan>> plansStream}) = _$_PlansState;

  @override
  Option<List<Plan>> get initialplans;
  @override
  Stream<List<Plan>> get plansStream;

  @override
  _PlansState copyWith(
      {Option<List<Plan>> initialplans, Stream<List<Plan>> plansStream});
}
